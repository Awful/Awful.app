//  UserDefaults+Settings.swift
//
//  Copyright 2019 Awful Contributors. CC BY-NC-SA 3.0 US https://github.com/Awful/Awful.app

import Foundation

// MARK: Keys

/**
 Keys used to store Awful's settings in UserDefaults.

 KVO-compliant properties are generated by Sourcery (see `UserDefaults+Settings.stencil` and `UserDefaults+Settings.generated.swift`). The value type is assumed to be `Bool` when not otherwise specified.
 */
public enum SettingsKeys {
    public static let automaticallyEnableDarkMode = "auto_dark_theme"
    public static let automaticallyPlayGIFs = "autoplay_gifs"
    public static let confirmNewPosts = "confirm_before_replying"
    // sourcery: valueType = String?
    public static let customBaseURLString = "custom_base_URL"
    // sourcery: valueType = String!
    public static let defaultDarkTheme = "default_dark_theme_name"
    // sourcery: valueType = String!
    public static let defaultLightTheme = "default_light_theme_name"
    public static let embedTweets = "embed_tweets"
    // sourcery: valueType = Double
    public static let fontScale = "font_scale"
    public static let hideSidebarInLandscape = "hide_sidebar_in_landscape"
    public static let isDarkModeEnabled = "dark_theme"
    public static let isHandoffEnabled = "handoff_enabled"
    public static let isPullForNextEnabled = "pull_for_next"
    // sourcery: valueType = String?
    public static let lastOfferedPasteboardURLString = "last_offered_pasteboard_URL"
    public static let loggedInUserCanSendPrivateMessages = "can_send_private_messages"
    // sourcery: valueType = String?
    public static let loggedInUserID = "userID"
    // sourcery: valueType = String?
    public static let loggedInUsername = "username"
    public static let openCopiedURLAfterBecomingActive = "clipboard_url_enabled"
    public static let openTwitterLinksInTwitter = "open_twitter_links_in_twitter"
    public static let openYouTubeLinksInYouTube = "open_youtube_links_in_youtube"
    public static let postLargeImagesAsThumbnails = "automatic_timg"
    // sourcery: valueType = String?
    public static let rawDefaultBrowser = "default_browser"
    public static let showAuthorAvatars = "show_avatars"
    public static let jumpToPostEndOnDoubleTap = "jump_to_post_end_on_double_tap"
    public static let enableHaptics = "enable_haptics"
    public static let enableCustomTitlePostLayout = "enable_custom_title_post_layout"
    public static let enableFrogAndGhost = "frog_and_ghost_enabled"
    public static let showImages = "show_images"
    public static let showThreadTagsInThreadList = "show_thread_tags"
    public static let showTweaksOnShake = "show_tweaks_on_shake"
    public static let showUnreadAnnouncementsBadge = "show_unread_announcements_badge"
    public static let sortUnreadBookmarksFirst = "bookmarks_sorted_unread"
    public static let sortUnreadForumThreadsFirst = "forum_threads_sorted_unread"
}

// MARK: Keys still used in Objective-C code

public extension UserDefaults {

    // If you can't find anywhere these properties are used, please delete them!

    @objc class var automaticallyEnableDarkModeKey: String {
        SettingsKeys.automaticallyEnableDarkMode
    }
    
    @objc class var isDarkModeEnabledKey: String {
        SettingsKeys.isDarkModeEnabled
    }
}

// MARK: Observation helpers

public extension UserDefaults {

    /**
     Calls a closure whenever the value for a particular keypath is changed.
     
     Unlike the closure passed to `observe(_:options:changeHandler:)`, this changeHandler is always called on the main queue.
     
     Also, including `.new` for the `options` parameter here doesn't seem to result in the closure getting passed anything for `change.newValue`. Not sure if we're doing something weird here, but it's actually easier to just ask the `UserDefaults` instance for the current value anyway, so that's the recommended approach.
     */
    func observeOnMain<Value>(
        _ keyPath: KeyPath<UserDefaults, Value>,
        options: NSKeyValueObservingOptions = [],
        changeHandler: @escaping (UserDefaults, NSKeyValueObservedChange<Value>) -> Void)
        -> NSKeyValueObservation
    {
        return observe(keyPath, options: options, changeHandler: { object, change in
            DispatchQueue.main.async {
                changeHandler(object, change)
            }
        })
    }
    
    /**
     Add several `UserDefaults` observers at once. Each observer will be called on the main queue.
     
     For example:
     
     var observers: [NSKeyValueObservation] = []
     
     observers += UserDefaults.standard.observeSeveral {
         $0.observe(\.showAvatars) { defaults in
             print("showAvatars is now \(defaults.showAvatars)")
         }
     }
     
     Note that there's no provision for `NSKeyValueObservingOptions` or `NSKeyValueObservedChange`; this is a convenience method for adding several observers that react to settings changes, and the assumption is that the current value is desired and will be obtained from the passed-in `UserDefaults` instance (as in the example).
     */
    func observeSeveral(_ block: (ObserveSeveralHelper) -> Void) -> [NSKeyValueObservation] {
        let helper = ObserveSeveralHelper(self)
        block(helper)
        return helper.observers
    }
    
    /// - Seealso: `UserDefaults.observeSeveral(_:)`.
    final class ObserveSeveralHelper {
        private let defaults: UserDefaults
        fileprivate var observers: [NSKeyValueObservation] = []
        
        fileprivate init(_ defaults: UserDefaults) {
            self.defaults = defaults
        }
        
        /**
         Add a key-value observer for each provided key path. The change handler is called on the main queue whenever any of the key paths change.
         
         The added observers are all included in the return value from `UserDefaults.observeSeveral(_:)`.
         
         If `options` contains `.initial`, then `changeHandler` will be called immediately, but exactly once (no matter how many `keyPaths` are provided).
         
         Passing `.old` and/or `.new` in `options` is probably not terribly useful, as `changeHandler` doesn't have access to the `NSKeyValueObservedChange` instance.
         */
        public func observe<Value>(_ keyPaths: KeyPath<UserDefaults, Value>..., options: NSKeyValueObservingOptions = [], changeHandler: @escaping (UserDefaults) -> Void) {
            var noninitialOptions = options
            noninitialOptions.remove(.initial)
            observers += keyPaths.map { keyPath in
                return defaults.observeOnMain(keyPath, options: noninitialOptions, changeHandler: { defaults, change in
                    changeHandler(defaults)
                })
            }
            if options.contains(.initial) {
                changeHandler(defaults)
            }
        }
    }
}

// MARK: Mass deletion

public extension UserDefaults {
    func removeAllObjectsInMainBundleDomain() {
        guard let bundleID = Bundle.main.bundleIdentifier else { return }
        setPersistentDomain([:], forName: bundleID)
    }
}
